# .NET 面试

## `C#`

### 1. 值类型与引用类型
  * **值类型**：直接存储数据本身，如int、bool、struct、enum等，存储在栈（Stack）上（或作为引用类型的字段时存储在堆上）。
  * **引用类型**：储存数据的引用（内存地址），实际数据在堆（Heap）上，如string、class、array、delegate等。
  * 区别：
    * 赋值行为：值类型赋值时赋值数据本身；引用类型赋值时赋值时复制引用（指向同一堆内存）。
    * 内存管理：值类型超出作用域自动释放；引用类型由GC（垃圾回收器）管理生命周期。
  * 代码举例：

      ```csharp
      // 值类型示例
      int a = 10;
      int b = a; // 复制值，b独立于a
      b = 20;
      Console.WriteLine(a); // 输出10（a不受影响）

      // 引用类型示例
      class Person { public int Age; }
      Person p1 = new Person { Age = 20 };
      Person p2 = p1; // 复制引用，p1和p2指向同一对象
      p2.Age = 30;
      Console.WriteLine(p1.Age); // 输出30（p1受影响）
      ```

  * 方法参数传递，值类型和引用类型的传递方式区别
    * 值类型：方法内修改不会影响外部变量。
    * 引用类型：默认按引用类型传递的引用地址，方法内部修改对象内容会影响外部（指向同一对象）

### 2. 装箱（Boxing）和拆箱（Unboxing）  
  * **装箱**：将值类型转换为引用类型（object或接口）
  * **拆箱**：将引用类型（装箱后的对象）转换回值类型

### 3. 接口和抽象类
  * **接口**：仅定义方法、属性、事件或索引器的签名（无实现）。`Interface`定义，成员默认public。
  * **抽象类**：可包含抽象成员和具体成员的类，不能实例化。`abstract`定义，成员可指定访问修饰符。
  * 接口和抽象类区别

    | 维度 | 接口 | 抽象类 |
    |------|------|--------|
    | 继承方式 | 支持多继承（一个类可实现多个接口） | 单继承（一个类只能继承一个抽象类） |
    | 成员实现 | 所有成员无实现（纯契约） | 可混合抽象成员（无实现）和具体成员 |
    | 访问修饰符 | 成员默认public，不可修改 | 成员可指定public/protected等 |
    | 构造函数 | 无构造函数 | 有构造函数（供派生类调用） |
    | 字段 | 不能包含字段（仅属性/方法等） | 可以包含字段 |
    | 版本兼容 | 新增成员会导致所有实现类必须修改 | 可新增具体成员，不影响派生类 |

  * 什么时候用接口？什么时候用抽象类？
    * 优先用接口场景：
      1. 需要继承多能力时
      2. 定义跨多个不相关类的通用功能（如IDisposable接口）
      3. 纯契约设计，不提供默认实现（如服务接口）
    * 优先用抽象类场景：
      1. 多个相关类共享部分实现逻辑（提取公共代码）
      2. 需要定义字段或构造函数时
      3. 希望控制继承层次（单继承体系），且可能后续扩展具体方法
  * 接口和抽象类在依赖注入中的应用场景
    * 接口是依赖注入的核心，用于定义服务契约，实现依赖倒置（高层模块依赖抽象）

        ```csharp
        // 接口定义服务
        public interface IUserService { void AddUser(); }

        // 具体实现
        public class UserService : IUserService { ... }

        // 注入时依赖接口，而非具体类
        public class UserController
        {
            private readonly IUserService _userService;
            public UserController(IUserService userService) // 依赖注入
            {
                _userService = userService;
            }
        }
        ```

    * 抽象类较少直接用于依赖注入，但若多个服务共享基础逻辑，可作为基类

### 4. 泛型

### 5. 委托与事件

### 6. 匿名方法与 Lambda 表达式